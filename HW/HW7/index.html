<html>
<head>
<title>INFO 3300 HW7</title>
<link href="https://fonts.googleapis.com/css?family=Slabo+27px" rel="stylesheet">
<script src="https://d3js.org/d3.v4.min.js"></script>
<style>
body { font-family: 'Slabo 27px', Calibri, sans-serif; }
svg { border: solid #ccc 1px; }
</style>
</head>
<body>
<h3>Problem 1</h3>
<style>
.grid-container {
  display: grid;
  grid-template-columns: auto auto auto auto;
  padding: 0px;
  grid-gap: 10px;
}
.grid-item {
  border: 1px solid black;
  padding: 0px;
  font-size: 30px;
  height: 200px;
  width:250px;
}
</style>

<div class="grid-container">
  <div class="grid-item" id = "plot1"></div>
  <div class="grid-item"></div>
  <div class="grid-item"></div>
  <div class="grid-item">4</div>
  <div class="grid-item">5</div>
  <div class="grid-item">6</div>
  <div class="grid-item">7</div>
  <div class="grid-item">8</div>
</div>

<script id="notes">

var height = 200;
var width = 250;
var padding = 20;

// This function will behave like Math.random(), but everyone will get
//  the same random numbers in the same order, so we can try to fit the
//  same original clusters.
// From http://stackoverflow.com/questions/521295/javascript-random-seeds
var seed = 3;
function seededRandom() {
  var x = Math.sin(seed++) * 10000;
  return x - Math.floor(x);
}

var svg = d3.select("#plot1").append("svg").attr("height", height).attr("width", width);

// // Create a "blur" filter
// svg.append("defs")
// .append("filter").attr("id", "blur")
// .attr("x", "-50%").attr("y", "-50%")
// .attr("height", "200%").attr("width", "200%")
// .append("feGaussianBlur").attr("in", "SourceGraphic").attr("stdDeviation", 10);

var points, lines, circles
var centroids, centroidCircles;

var gaussian = d3.randomNormal();

var xScale = d3.scaleLinear().domain([0,1]).range([padding, width - padding]);
var yScale = d3.scaleLinear().domain([0,1]).range([height - padding, padding]);



// Then make a clustering model that tries to approximate it
//centroids = kMeansModel(1);


var points = [];
var numPts = 30;
var theChosen_idx = Math.floor(Math.random() * (numPts));
// Sample points from this cluster
for (var i = 0; i < 30; i++) {
  var myLabel = i == theChosen_idx ? 1 : 0;
  points.push({
    label: myLabel,
    x: padding + Math.random() * (width - 2*padding), // "noise" is scaled by "spread" param
    y: padding + Math.random() * (height - 2*padding)
  });
}
console.log(points);




// Place a blurry indication of where the cluster "should" be.
// svg.append("circle")
// .attr("class", "realCenter")
// .attr("cx", xScale(center.x))
// .attr("cy", yScale(center.y))
// .attr("r", xScale(spread) - xScale(0))
// //.attr("filter", "url(#blur)")
// .style("fill", "#9c9");


      // Visual representation
  //     svg.append("circle")
  //     .attr("class", "point")
  //     .attr("cx", function(d) { return xScale(center.x); })
  //     .attr("cy", function(d) { return yScale(center.y); })
  //     .attr("r", 3)
  //     .style("fill", "green")
  //     .style("opacity", 0.5)
  //   }
  // }
  //
  // // Implement "pop out" effect to emphasize origin clusters
  // circles = svg.selectAll(".point").data(points)
  // .transition().duration(1000)
  // .attr("cx", function(d) { return xScale(d.x); })
  // .attr("cy", function(d) { return yScale(d.y); });

//   // Create lines that will connect points to their assigned cluster
//   lines = svg.selectAll("line").data(points);
//
//   lines = lines.enter().append("line")
//   .attr("x1", function(d) { return xScale(d.x); })
//   .attr("y1", function(d) { return yScale(d.y); })
//   .attr("x2", function(d) { return xScale(d.x); })
//   .attr("y2", function(d) { return yScale(d.y); })
//   .style("stroke", "#aaa").merge(lines);
//
//   return points;
// }




</script>




</body>
</html>
